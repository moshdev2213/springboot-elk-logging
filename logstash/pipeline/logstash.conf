input {
  beats {
    port => 5044
  }
}

filter {
  # Add environment-specific tags
  if [environment] {
    mutate {
      add_tag => ["env-%{environment}"]
    }
  }
  
  # Service-specific tagging (matches full service names with -service suffix)
  if [service][name] == "order-service" {
    mutate {
      add_tag => ["order-service"]
    }
  }
  
  if [service][name] == "inventory-service" {
    mutate {
      add_tag => ["inventory-service"]
    }
  }
  
  # Parse JSON logs if they exist
  if [message] =~ /^\{.*\}$/ {
    json {
      source => "message"
      # Skip malformed JSON gracefully
      skip_on_invalid_json => true
    }
  }
  
  # Extract log level from message if not already present
  if ![level] and [message] {
    grok {
      match => { "message" => "(?<level>DEBUG|INFO|WARN|ERROR|TRACE|FATAL)" }
      tag_on_failure => []
    }
  }
  
  # Add timestamp if not present
  if ![timestamp] {
    mutate {
      add_field => { "timestamp" => "%{@timestamp}" }
    }
  }
  
  # Clean up fields - remove Filebeat metadata if not needed
  mutate {
    remove_field => ["agent", "ecs", "host", "input", "log"]
  }
}

output {
  # Environment-specific indices for better organization
  if [environment] == "prod" {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "microservices-prod-logs-%{+YYYY.MM.dd}"
    }
  } else if [environment] == "stage" {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "microservices-stage-logs-%{+YYYY.MM.dd}"
    }
  } else if [environment] == "dev" {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "microservices-dev-logs-%{+YYYY.MM.dd}"
    }
  } else {
    elasticsearch {
      hosts => ["elasticsearch:9200"]
      index => "microservices-local-logs-%{+YYYY.MM.dd}"
    }
  }
  
  # Output to console for debugging (consider disabling in production)
  if [environment] != "prod" {
    stdout {
      codec => rubydebug
    }
  }
}